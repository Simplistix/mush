How Mush works
==============

.. currentmodule:: mush

.. note:: 

  This documentation explains how Mush works using fairly abstract
  examples. If you'd prefer more "real world" examples please see the
  :doc:`examples` documentation.

.. _constructing-runners:

Constructing runners
--------------------

Mush works by assembling a number of callables into a :class:`Runner`:

.. code-block:: python

  from mush import Runner

  def func1():
      print('func1')

  def func2():
      print('func2')

  runner = Runner(func1, func2)

Once assembled, a runner can be called any number of times. Each time
it is called, it will call each of its callables in turn:

>>> runner()
func1
func2

More callables can be added to a runner:

.. code-block:: python

 def func3():
     print('func3')

 runner.append(func3)

If you want to add several callables in one go, you can use the
runner's :meth:`~Runner.extend` method:

.. code-block:: python

 def func4():
     print('func4')

 def func5():
     print('func5')

 runner.extend(func4, func5)

Now, when called, the runner will call all five functions:

>>> runner()
func1
func2
func3
func4
func5

Runners can also be added together to create a new runner:

.. code-block:: python

  runner1 = Runner(func1)
  runner2 = Runner(func2)
  runner3 = runner1 + runner2

This addition does not modify the existing runners, but does give the
result you'd expect:

>>> runner1()
func1
>>> runner2()
func2
>>> runner3()
func1
func2

This can also be done by passing runners in when creating a new runner
or calling the extend method on a runner, for example:

.. code-block:: python

  runner1 = Runner(func1)
  runner2 = Runner(func2)
  runner4_1 = Runner(runner1, runner2)
  runner4_2 = Runner()
  runner4_2.extend(runner1, runner2)

In both cases, the results are as you would expect:

>>> runner4_1()
func1
func2
>>> runner4_2()
func1
func2

Finally, runners can be cloned, providing a way to encapsulate commonly
used base runners that can then be extended for each specific use case:

.. code-block:: python

  runner5 = runner3.clone()
  runner5.append(func4)

The existing runner is not modified, while the new runner behaves as
expected:

>>> runner3()
func1
func2
>>> runner5()
func1
func2
func4

.. _configuring-resources:

Configuring Resources
---------------------
Where Mush becomes useful is when the callables in a runner either
produce or require objects of a certain type. Given the right
configuration, Mush will wire these together enabling you to write
easily testable and reusable callables that encapsulate specific
pieces of functionality. This configuration is done either
imperatively, declaratively or using a combination of the two styles
as described in the sections below.

For the examples, we'll assume we have three types of resources:

.. code-block:: python

  class Apple: 
      def __str__(self):
          return 'an apple'
      __repr__ = __str__

  class Orange: 
      def __str__(self):
          return 'an orange'
      __repr__ = __str__

  class Juice:
      def __str__(self):
          return 'a refreshing fruit beverage' 
      __repr__ = __str__

Imperative configuration
~~~~~~~~~~~~~~~~~~~~~~~~

Imperative configuration requires no decorators and is great when
working with callables that come from another package or the standard
library:

.. code-block:: python

 def apple_tree():
      print('I made an apple')
      return Apple()

 def magician(fruit):
      print('I turned {0} into an orange'.format(fruit))
      return Orange()

 def juicer(fruit1, fruit2):
      print('I made juice out of {0} and {1}'.format(fruit1, fruit2))

The requirements are passed using the `requires` parameter when calling
:meth:`~Runner.append`. If more complex requirements need to be specified,
a :class:`requires` instance can be passed:

.. code-block:: python

  from mush import Runner, requires
  runner = Runner()
  runner.append(apple_tree)
  runner.append(magician, requires=Apple)
  runner.append(juicer, requires(fruit1=Apple, fruit2=Orange))

Calling this runner will now manage the resources, collecting them and
passing them in as configured:

>>> runner()
I made an apple
I turned an apple into an orange
I made juice out of an apple and an orange

Declarative configuration
~~~~~~~~~~~~~~~~~~~~~~~~~

This is done using the :class:`requires` decorator to mark the
callables with their requirements, which can specify the types
required for either arguments or keyword parameters:

.. code-block:: python

  from mush import requires

  def apple_tree():
      print('I made an apple')
      return Apple()

  @requires(Apple)
  def magician(fruit):
      print('I turned {0} into an orange'.format(fruit))
      return Orange()

  @requires(fruit1=Apple, fruit2=Orange)
  def juicer(fruit1, fruit2):
      print('I made juice out of {0} and {1}'.format(fruit1, fruit2))
      return Juice()

These can now be combined into a runner and executed. The runner will
extract the requirements stored by the decorator and will use them to
map the parameters as appropriate:

>>> runner = Runner(apple_tree, magician, juicer)
>>> runner()
I made an apple
I turned an apple into an orange
I made juice out of an apple and an orange
a refreshing fruit beverage

Hybrid configuration
~~~~~~~~~~~~~~~~~~~~

The two styles of configuration are entirely interchangeable, with
declarative requirements being inspected whenever a callable is added
to a runner, and imperative requirements being taken whenever they are
passed via the :meth:`~Runner.append` method:

.. code-block:: python

  @requires(Juice)
  def packager(juice):
      print('I put {0} in a bottle'.format(juice))
  
  def orange_tree():
      print('I made an orange')
      return Orange()

  trees = Runner(apple_tree, orange_tree)
  runner = trees.clone()
  runner.extend(juicer, packager)
  
This runner now ends up with bottled juice:

>>> runner()
I made an apple
I made an orange
I made juice out of an apple and an orange
I put a refreshing fruit beverage in a bottle

It's useful to note that imperative configuration will be used in
preference to declarative configuration where both are present:

.. code-block:: python

  runner = trees.clone()
  runner.append(juicer, requires(Orange, Apple))

This runner will give us juice made in a different order:

>>> runner()
I made an apple
I made an orange
I made juice out of an orange and an apple
a refreshing fruit beverage

.. _usage-periods:

Labels
------

It can be important to insert callables at the right point in a runner,
even if subsequent callables have been added to the runner. For this reason,
labels can be used to mark points in ther runner where more callables can
be inserted later.

As an example, consider a ring and some things that can be done to it:

.. code-block:: python

  class Ring:
      def __str__(self):
          return 'a ring'

  def forge():
      return Ring()

  def polish(ring):
      print('polishing {0}'.format(ring))

  def more_polish(ring):
      print('polishing {0} again'.format(ring))

  def engrave(ring):
      print('engraving {0}'.format(ring))

  def package(ring):
      print('packaging {0}'.format(ring))

These can now be added to a runner using labels so that even if the callables
are added at different times, they will still be added in the correct order:

.. code-block:: python

  from mush import Runner

  runner = Runner()
  point = runner.append(forge)
  point.add_label('forged')
  point.add_label('polished')
  runner['polished'].append(package, requires=Ring, label='packaged')
  runner['forged'].append(polish, requires=Ring)
  runner['forged'].append(more_polish, requires=Ring)
  runner['forged'].append(engrave, requires=Ring)

Even though the callables were added out order, they will be executed
correctly:

>>> runner()
polishing a ring
polishing a ring again
engraving a ring
packaging a ring

Sometimes, a callable needs to be called after other callables to do its
work but does not need or cannot accept objects of the type returned
by that callable. For example, and miss-using the fruit types from above:

.. code-block:: python

  def func1():
      return Apple()

  def func2(apple):
      print('func2 got {0}'.format(apple))
      return Orange()

  def func3(apple):
      print('func3 got {0}'.format(apple))

  def func4(orange):
      print('func4 processed {0}'.format(orange))

If we want :func:`func3` only to get called once :func:`func4` has
processed the :class:`Orange` but, for reasons of abstraction, 
we want to add the callables in the order defined above, the simplest
runner will not give us what we want:

>>> runner = Runner(func1)
>>> runner.append(func2, Apple)
<...>
>>> runner.append(func3, Apple)
<...>
>>> runner.append(func4, Orange)
<...>
>>> runner()
func2 got an apple
func3 got an apple
func4 processed an orange

The problem is that the runner hasn't been told that :func:`func3`
has a dependency on :class:`Orange`. This can be done using the
:func:`after` type wrapper to specify that :func:`func2` requires an
:class:`Orange` to exist, and for any other callables added to the
runner that need an :class:`Orange` to have been called first, but
that it must not be passed that orange:

.. code-block:: python

  from mush import Runner

  runner = Runner(func1)
  point = runner.append(func2, Apple)
  point.add_label('make_orange')
  runner.append(func3, Apple)
  runner['make_orange'].append(func4, Orange)

Now, even though we've added the callables in the order we want, we
get the order of calling that we need:

>>> runner()
func2 got an apple
func4 processed an orange
func3 got an apple

Specifying return types
-----------------------

As seen above, by default, Mush uses the type of the returned object to
decide the type of resource that has been returned. It can be useful
to configure different behaviour by specifying the return type of a callable.
There are several options for doing this, each covered below.

For the examples below, we'll use the fruit classes from above.

Returning multiple resources
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A callable can return a sequence of resources:

.. code-block:: python

  from mush import Runner, returns_sequence

  def orchard():
      return Apple(), Orange()

This can be used to provide both types of fruit:

>>> runner = Runner()
>>> runner.append(orchard, returns=returns_sequence())
<...>
>>> runner.append(juicer)
<...>
>>> runner()
I made juice out of an apple and an orange
a refreshing fruit beverage

This configuration can also be done using a decorator:

.. code-block:: python

  from mush import Runner, returns_sequence

  @returns_sequence()
  def orchard():
      return Apple(), Orange()

This means you don't have to explicitly append:

>>> runner = Runner(orchard, juicer)
>>> runner()
I made juice out of an apple and an orange
a refreshing fruit beverage

Overriding the type of a resource
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes you may need to force a returned resource to be of a
particular type. Say we want to make juice but only have pears and oranges,
but no apples:

.. code-block:: python

  class Pear: 
      def __str__(self):
          return 'a pear'

We can tell the runner to pretend the pear is an apple:

>>> runner = Runner(orange_tree)
>>> runner.append(Pear, returns=Apple)
<...>
>>> runner.append(juicer)
<...>
>>> runner()
I made an orange
I made juice out of a pear and an orange
a refreshing fruit beverage

We can also use a helper that returns a mapping and tell the runner to use
the keys of that mapping as the types for the values:

.. code-block:: python

  from mush import returns_mapping

  @returns_mapping()
  def desperation():
      print('oh well, a pear will have to do')
      return {Apple: Pear()}

We can now make juice even though we don't have apples:

>>> runner = Runner(orange_tree, desperation, juicer)
>>> runner()
I made an orange
oh well, a pear will have to do
I made juice out of a pear and an orange
a refreshing fruit beverage

If you have no control over a callable that returns an object of the 'wrong'
type, you have two options. You can either decorate it:

.. code-block:: python

  from mush import returns

  @returns(Apple)
  def make_pears():
      print('I made a pear')
      return Pear()

Now you can use the pear maker to get juice:

>>> runner = Runner(orange_tree, make_pears, juicer)
>>> runner()
I made an orange
I made a pear
I made juice out of a pear and an orange
a refreshing fruit beverage

.. _resource-parts:

Using parts of a resource
-------------------------

When pieces of functionality use settings provided either by command
line arguments or from configuration files, it's often cleaner to
structure that code to recieve the specific setting value rather than
the setting's container. It's certainly easier to test. Mush can take
care of the needed wiring when configured to do so using the
:class:`attr` and :class:`item` helpers:

.. code-block:: python

    from mush import Runner, attr, item, requires

    class Config(dict): pass

    class Args(object):
        fruit = 'apple'
        tree = dict(fruit='pear')

    def parse_args():
        return Args()

    def read_config():
        return Config(fruit='orange')

    @requires(attr(Args, 'fruit'),
              item(Config, 'fruit'),
              item(attr(Args, 'tree'), 'fruit'))
    @returns_sequence()
    def pick(fruit1, fruit2, fruit3):
        print('I picked {0}, {1} and {2}'.format(fruit1, fruit2, fruit3))
        picked = []
        for fruit in fruit1, fruit2:
            if fruit=='apple':
                picked.append(Apple())
            elif fruit=='orange':
                picked.append(Orange())
            else:
                raise TypeError('You have made a poor fruit choice')
        return picked

While the :func:`pick` function remains usable and testable on its
own:

>>> pick('apple', 'orange', 'pear')
I picked apple, orange and pear
[an apple, an orange]

It can also be added to a runner with the other necessary functions
and Mush will do the hard work:

>>> runner = Runner(parse_args, read_config, pick, juicer)
>>> runner()
I picked apple, orange and pear
I made juice out of an apple and an orange
a refreshing fruit beverage

.. _context-managers:

Context manager resources
-------------------------

A frequent requirement when writing scripts is to make sure that
when unexpected things happen they are logged, transactions are
aborted, and other necessary cleanup is done. Mush supports this
pattern by allowing context managers to be added as callables:

.. code-block:: python

    from mush import Runner, requires

    class Transactions(object):

        def __enter__(self):
            print('starting transaction')

        def __exit__(self, type, obj, tb):
            if type:
                print(obj)
                print('aborting transaction')
            else:
                print('committing transaction')
            return True

    def a_func():
        print('doing my thing')

    def good_func():
        print('I have done my thing')

    def bad_func():
        raise Exception("I don't want to do my thing")

The context manager is wrapped around all callables that are called
after it:

>>> runner = Runner(Transactions, a_func, good_func)
>>> runner()
starting transaction
doing my thing
I have done my thing
committing transaction

This gives it a chance to clear up when things go wrong:

>>> runner = Runner(Transactions, a_func, bad_func)
>>> runner()
starting transaction
doing my thing
I don't want to do my thing
aborting transaction
